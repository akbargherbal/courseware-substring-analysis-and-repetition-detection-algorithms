# ğŸ§  Variable-Length Repeated Substring Detection Algorithms

_A Complete Instructional Course Generated by an LLM_

---

## ğŸ“˜ Overview

This repository contains all instructional materials, code examples, and supporting artifacts for the course **â€œVariable-Length Repeated Substring Detection Algorithms.â€**
The entire course was **generated by an LLM (Large Language Model)** using a structured instructional design framework to ensure clarity, depth, and pedagogical rigor.

The course explores multiple algorithmic strategies for detecting repeated substrings (or n-grams) of variable lengths within text data â€” from simple sliding windows to production-grade suffix arrays and streaming systems.

---

## ğŸ—ï¸ Course Design Philosophy

This course was _not_ written by hand â€” it was **authored by an LLM under explicit meta-instructional constraints** to simulate how a human instructor would progressively teach algorithmic thinking.

The design emphasizes:

- **Concrete â†’ Abstract progression:** always start from examples (â€œbananaâ€) before introducing theory.
- **â€œShow failure before solutionâ€:** demonstrate naive approaches and their limitations first.
- **Stepwise abstraction:** introduce one new concept per section.
- **Pair-programming style narration:** explanations simulate an expert thinking aloud.
- **Production awareness:** every algorithm is tied to real-world trade-offs.

---

## ğŸ§© Course Modules

| Module       | Title                              | Core Focus                                                    |
| :----------- | :--------------------------------- | :------------------------------------------------------------ |
| **0**        | _Prerequisites and Problem Setup_  | Foundational terms, motivating examples                       |
| **1**        | _Sliding Window Approach_          | Naive and parameterized n-gram counting                       |
| **2**        | _Suffix Array Method_              | Efficient substring analysis via sorting and LCP arrays       |
| **3**        | _Hash-Based Method_                | Rolling hash optimization for faster detection                |
| **4**        | _Streaming Approach_               | Memory-bounded and chunked file processing                    |
| **5**        | _Comparative Analysis & Selection_ | Benchmarking and algorithmic trade-offs                       |
| **6**        | _Extensions and Applications_      | Case studies: plagiarism, DNA, log analysis                   |
| **Appendix** | _Implementation Gallery_           | Full reference implementations, tests, and optimization notes |

For the detailed instructional sequence, see [`ZEN_toc.md`](./ZEN_toc.md).

---

## ğŸ§® Algorithms Covered

1. **Sliding Window (O(LÃ—n))** â€” simplest, ideal for small data.
2. **Suffix Array (O(L log L))** â€” scalable, great for large repeated queries.
3. **Rolling Hash (Expected O(LÃ—n))** â€” fast, pragmatic, widely used in text and DNA analysis.
4. **Streaming Counter (O(L))** â€” for data too large to fit in memory.

Each algorithm is presented in a _teaching-first, production-second_ manner:

- Start with a literal hand-traced example.
- Progress to explicit code.
- Then optimize and analyze complexity.
- Finally, explain _when and why_ to use it.

---

## ğŸ§  How to Use This Repository

### 1. **For Learners**

- Begin with **Module 0** and follow sequentially.
- Run each code cell manually â€” youâ€™ll learn more by tracing.
- Compare algorithm outputs on the same input (e.g., `"banana"`).

### 2. **For Instructors**

- The outline (`ZEN_toc.md`) doubles as a _generation template_ â€” it can be reused with an LLM to regenerate or adapt the course for other domains.
- Each â€œLLM Generation Hintâ€ acts as a structured _prompting scaffold_.

### 3. **For Developers**

- Explore `implementations/` for reference code.
- Each algorithm includes type hints, comments, and complexity notes.
- Run `tests/` to validate equivalence across methods.

---

## ğŸ§‘â€ğŸ’» Repository Structure

```
ğŸ“‚ variable-length-repeated-substring-course/
â”œâ”€â”€ README.md                â† This file
â”œâ”€â”€ ZEN_toc.md               â† Instructional design outline (LLM generation blueprint)
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ 00_prerequisites/
â”‚   â”œâ”€â”€ 01_sliding_window/
â”‚   â”œâ”€â”€ 02_suffix_array/
â”‚   â”œâ”€â”€ 03_hash_based/
â”‚   â”œâ”€â”€ 04_streaming/
â”‚   â”œâ”€â”€ 05_comparative_analysis/
â”‚   â””â”€â”€ 06_applications/
â”œâ”€â”€ implementations/
â”‚   â”œâ”€â”€ sliding_window.py
â”‚   â”œâ”€â”€ suffix_array.py
â”‚   â”œâ”€â”€ rolling_hash.py
â”‚   â”œâ”€â”€ streaming_counter.py
â”‚   â””â”€â”€ benchmarks.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_correctness.py
â”‚   â””â”€â”€ test_performance.py
â””â”€â”€ data/
    â””â”€â”€ sample_texts/
```

---

## ğŸ§ª Requirements

- Python â‰¥ 3.9
- Dependencies: `numpy`, `pandas`, `matplotlib` (for analysis modules)

Install with:

```bash
pip install -r requirements.txt
```

---

## ğŸ§­ Learning Outcomes

By the end of this course, learners will:

- Understand multiple strategies for repeated substring detection.
- Implement, optimize, and benchmark algorithms across datasets.
- Make informed trade-offs between time, memory, and maintainability.
- Recognize how professional engineers reason about algorithm choice.

---

## âš™ï¸ Meta-Generation Note

This course was **LLM-generated end-to-end** using the meta-prompt structure embedded in [`ZEN_toc.md`](./ZEN_toc.md).
The content was intentionally designed to test **pedagogical alignment and algorithmic reasoning capabilities** of language models.

If you reuse this outline, please cite:

> _â€œLLM-Generated Instructional Course Framework for Algorithmic Educationâ€ (ZEN Outline, 2025)._

---

## ğŸª´ License

All code and instructional content are released under the **MIT License**.
You are free to use, adapt, and redistribute with attribution.

---

## ğŸ’¬ Acknowledgements

Special thanks to:

- The instructional design principles that inspired the **ZEN framework** â€” _â€œBuild from concrete to abstract, failure to solution.â€_
- The LLM that generated the entire curriculum.
